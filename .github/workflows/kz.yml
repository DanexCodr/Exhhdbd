name: Check JNI Sync (Java â†” native .so)

on:
  push:
    branches:
      - main

jobs:
  jni-sync-check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java 7
        uses: actions/setup-java@v4
        with:
          java-version: '7'
          distribution: 'zulu'

      - name: Prepare Python environment
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      - name: Extract Java sources from classes.jar
        run: |
          mkdir java_src
          unzip -qq classes.jar -d java_src

      - name: Compile Java sources (Java 7 compatible)
        run: |
          mkdir -p build_classes
          javac -source 1.7 -target 1.7 -d build_classes $(find java_src -name "*.java")

      - name: Run JNI sync check
        run: |
          cat << 'EOF' > check_jni_sync.py
          import os, re, subprocess, sys

          JAVA_NATIVE_RE = re.compile(r'\bnative\s+[^\s;]+\s+([A-Za-z0-9_$]+)\s*\(')

          def gather_java_files(src):
              return [os.path.join(dp, f) for dp, _, fn in os.walk(src) for f in fn if f.endswith('.java')]

          def parse_natives(files):
              natives = []
              for f in files:
                  with open(f, 'r', errors='ignore') as fh:
                      src = fh.read()
                  cls = os.path.splitext(os.path.basename(f))[0]
                  for m in JAVA_NATIVE_RE.findall(src):
                      natives.append((cls, m))
              return natives

          def list_symbols(so):
              try:
                  out = subprocess.check_output(['nm', '-D', '--defined-only', so], stderr=subprocess.DEVNULL).decode()
                  return set([l.split()[-1] for l in out.splitlines() if l.strip()])
              except:
                  out = subprocess.check_output(['readelf', '-Ws', so], stderr=subprocess.DEVNULL).decode()
                  return set([l.split()[-1] for l in out.splitlines() if l.strip()])

          java_files = gather_java_files('java_src')
          natives = parse_natives(java_files)
          if not natives:
              print('No native methods found in Java sources.')
              sys.exit(0)

          print(f"Found {len(natives)} native methods in Java sources.")

          so_files = [f for f in os.listdir('.') if f.endswith('.so')]
          if not so_files:
              print('No .so files found in repo root.')
              sys.exit(1)

          all_symbols = set()
          for so in so_files:
              all_symbols |= list_symbols(so)

          missing = []
          for cls, method in natives:
              expected = f"Java_{cls.replace('_','_1')}_{method}"
              if not any(s.startswith(expected) for s in all_symbols):
                  missing.append(f"{cls}.{method}")

          if missing:
              print("Missing native implementations for:")
              for m in missing:
                  print("  -", m)
              sys.exit(1)
          else:
              print("All native methods have matching JNI implementations.")
          EOF

          python check_jni_sync.py

      - name: Upload rebuilt classes
        uses: actions/upload-artifact@v4
        with:
          name: rebuilt-classes
          path: build_classes
